analytic

# variables go here...
# only floats supported right now.
# [type] [name] [min val] [max val] [default val]

::begin parameters
float gain 0.0 100.0 30.0
bool interpolation 1
::end parameters


# Then comes the shader. This should be GLSL code
# that defines a function called BRDF (although you can
# add whatever other functions you want too). 

::begin shader

const uint n_th_i = 16;
const uint n_ph_i = 1;
const uint n_th_o = 1;
const uint n_ph_o = 1;

const vec3 table[] = {
vec3(224.878174, 26.679844, 12.184758),
vec3(0.560382, 0.101801, 0.071040),
vec3(0.138791, 0.023183, 0.014029),
vec3(0.061821, 0.009504, 0.005221),
vec3(0.033028, 0.005201, 0.002434),
vec3(0.019125, 0.002790, 0.001482),
vec3(0.013579, 0.001798, 0.001034),
vec3(0.009154, 0.001058, 0.000653),
vec3(0.007178, 0.000763, 0.000459),
vec3(0.006253, 0.000723, 0.000338),
vec3(0.005205, 0.000650, 0.000213),
vec3(0.004669, 0.000578, 0.000152),
vec3(0.004219, 0.000560, 0.000121),
vec3(0.004228, 0.000523, 0.000137),
vec3(0.004456, 0.000403, 0.000144),
vec3(0.004870, 0.000396, 0.000170)
};
const float PI = 3.14159265358979323846;


float theta(vec3 v, vec3 N)
{
    return acos(dot(v,N));
}

float phi(vec3 v, vec3 N, vec3 X)
{
    vec3 Y = normalize(cross(N,X));
    float costheta = clamp(dot(v,N),-1,1);
    float sintheta = sqrt(1-costheta*costheta);
    float cosphi = dot(v,X) / sintheta;
    float sinphi = dot(v,Y) / sintheta;
    float phi = acos(cosphi);
    return sinphi < 0 ? 2*PI-phi : phi;
}

uint round_idx(float v, const uint idxmax){
    return uint(clamp(uint(v) + 0.5, 0, idxmax-uint(1)));
}

vec3 neighbor(float theta_i_fidx, float phi_i_fidx, float theta_o_fidx, float phi_o_fidx)
{
    // Convert floating index to integer index
    uint theta_i_idx = round_idx(theta_i_fidx, n_th_i);
    uint phi_i_idx = round_idx(phi_i_fidx, n_ph_i);
    uint theta_o_idx = round_idx(theta_o_fidx, n_th_o);
    uint phi_o_idx = round_idx(phi_o_fidx, n_ph_o);

    uint idx = phi_o_idx;
    idx += uint(theta_o_idx * n_ph_o);
    idx += uint(phi_i_idx * n_ph_o * n_th_o);
    idx += uint(theta_i_idx * n_ph_o * n_th_o * n_ph_i);
    return table[idx];
}

vec3 bilinear(float theta_i_fidx, float phi_i_fidx, float theta_o_fidx, float phi_o_fidx)
{
    uint theta_i_idx[2] = {uint(clamp(uint(theta_i_fidx), 0, n_th_i-uint(1))), uint(clamp(uint(theta_i_fidx)+uint(1), 0, n_th_i-uint(1)))};
    uint phi_i_idx = round_idx(phi_i_fidx, n_ph_i);
    uint theta_o_idx = round_idx(theta_o_fidx, n_th_o);
    uint phi_o_idx = round_idx(phi_o_fidx, n_ph_o);

    uint idx[2];
    for (int i=0; i<2; i++){
        idx[i] = phi_o_idx;
        idx[i] += uint(theta_o_idx * n_ph_o);
        idx[i] += uint(phi_i_idx * n_ph_o * n_th_o);
        idx[i] += uint(theta_i_idx[i] * n_ph_o * n_th_o * n_ph_i);
    }
    
    float theta_i_ratio = theta_i_fidx - theta_i_idx[0];
    vec3 val = (1.0 - theta_i_ratio) * table[idx[0]] + theta_i_ratio * table[idx[1]];
    return val;
}

vec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y )
{    
    float theta_i = theta(L,N);
    float phi_i = phi(L,N,X);
    float theta_o = theta(V,N);
    float phi_o = phi(V,N,X);

    // Convert angle to floating index
    float theta_i_fidx = theta_i / (0.5 * PI / float(n_th_i));
    float phi_i_fidx = phi_i / (0.5 * PI / float(n_ph_i));
    float theta_fidx_o = theta_o / (0.5 * PI / float(n_th_o));
    float phi_o_fidx = phi_o / (0.5 * PI / float(n_ph_o));

    vec3 val;
    if (interpolation)
       val = bilinear(theta_i_fidx, phi_i_fidx, theta_fidx_o, phi_o_fidx);
    else
       val = neighbor(theta_i_fidx, phi_i_fidx, theta_fidx_o, phi_o_fidx);


    return clamp(val / max(dot(V,N), 0.01) * gain, 0, 1); // if multiply V and N, have to convert.
    // return val * gain; // else
}

::end shader
